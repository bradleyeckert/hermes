# 5.5 SOFTWARE UNIT implementation and VERIFICATION

## 5.5.1 Implement each SOFTWARE UNIT

The MANUFACTURER shall implement each SOFTWARE UNIT.

## 5.5.2 Establish SOFTWARE UNIT VERIFICATION PROCESS

The MANUFACTURER shall establish strategies, methods and procedures for verifying each the
SOFTWARE UNITS. Where VERIFICATION is done by testing, the test procedures shall be
EVALUATED for correctness adequacy.
NOTE It is acceptable to combine integration testing and SOFTWARE SYSTEM testing into a single plan and set of
ACTIVITIES.

## 5.5.3 SOFTWARE UNIT acceptance criteria

The MANUFACTURER shall establish acceptance criteria for SOFTWARE UNITS prior to integration
into larger SOFTWARE ITEMS as appropriate, and ensure that SOFTWARE UNITS meet acceptance
criteria.
NOTE Examples of acceptance criteria are:
– does the software code implement requirements including RISK CONTROL measures?
– is the software code free from contradiction with the interfaces documented in the detailed design of the
SOFTWARE UNIT?
– does the software code conform to programming procedures or coding standards?

## 5.5.4 Additional SOFTWARE UNIT acceptance criteria

When present in the design, the MANUFACTURER shall include additional acceptance criteria as
appropriate for:
a) proper event sequence;
b) data and control flow;
c) planned resource allocation;
d) fault handling (error definition, isolation, and recovery);
e) initialisation of variables;
f) self-diagnostics;
g) memory management and memory overflows; and
h) boundary conditions.
{Class C}

## 5.5.5 SOFTWARE UNIT VERIFICATION

The MANUFACTURER shall perform the SOFTWARE UNIT VERIFICATION and document the results.

### 5.5.1.3 moletest Unit Tests
`moletest.c` performs unit tests by instantiating two **mole** ports Alice and Bob and connecting them together.
The `ciphr` function of Alice calls the `molePutc` function of Bob and vice-versa.
This simulates two UARTs connected by a Null-Modem cable.
```C
port_ctx Alice;
port_ctx Bob;
```
The `main` function in `moletest.c` performs a sequence of tests on the API.
If it gets through the sequence without errors,
the return code is 0. Otherwise, it returns an error code corresponding to the test that failed.
